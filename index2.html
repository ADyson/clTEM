<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>clTEM by ADyson</title>
    <link rel="stylesheet" href="stylesheets/styles2.css">
    <script src="http://d3js.org/d3.v3.js"></script>
    <style>
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}
</style>
  </head>
    <body>
      <div class="header">
      <div class="column">
      <div id="title">
        <h1>clTEM</h1>
        <h4>OpenCL TEM/STEM simulation code</h4>
        <span class="credits left">Project maintained by <a href="https://github.com/ADyson">ADyson</a></span>
        <span class="credits right">Hosted on GitHub Pages</span>
      </div>
   </div>
</div>
<div class="column">
      <div id="graph"></div>
      <p></p>
        <h2><a id="intro" href="#intro">></a>Introduction</h2>
      <p><b>clTEM</b> is a multislice simulation software designed to produce realistic simulated
        electron microscope images. <b>clTEM</b> has been designed with performance in mind and uses
         OpenCL as a means to accelerate the calculations on multicore CPU's and GPU's.</p>
      <p><b>clTEM</b> can be used to perform TEM, STEM and CBED image simulations. The simulation
        resolution can be adjusted between 128<sup>2</sup> and 4096<sup>2</sup> pixels in
         powers of 2. For STEM the number of pixels in the output image is independent of the
          simulation resolution and can be set to arbitrary values.</p>
      <p>There is also support for several different methods of potential calculation,
        the standard approximate method, a more accurate 3D method, and the most accurate
         finite difference solution to provide flexible performance and accuracy</p>
      <p>Simulations can be performed using different simulated CCD's including the effects
         of binning and electron dose on the final images.</p>
      <p>Simulations can also be performed over custom areas of the full input model (in x,y),
         for STEM, TEM and CBED. For STEM, an unlimited number of detectors can be simulated at once,
          characterised by their inner and outer angles and also their position relative to the origin.</p>
   </div>
      <script>

var margin = {top: 20, right: 80, bottom: 30, left: 60},
    width = 720 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;


var x = d3.scale.linear()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var color = d3.scale.category10();

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom")
    .tickValues([256,512,1024,2048]);

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var line = d3.svg.line()
    .x(function(d) { return x(d.resolution); })
    .y(function(d) { return y(d.time); });

var svg = d3.select("#graph").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
 .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

d3.tsv("data.tsv", function(error, data) {
 color.domain(d3.keys(data[0]).filter(function(key) { return key !== "resolution"; }));

 data.forEach(function(d) {
    d.resolution = +d.resolution;
 });

 var method = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {resolution: d.resolution, time: +d[name]};
      })
    };
 });

 x.domain([0,2048]);

 y.domain([
    d3.min(method, function(c) { return d3.min(c.values, function(v) { return v.time; }); }),
    d3.max(method, function(c) { return d3.max(c.values, function(v) { return v.time; }); })
 ]);

 svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

 svg.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Time (ms)");

 var methods = svg.selectAll(".method")
      .data(method)
    .enter().append("g")
      .attr("class", "method");

 methods.append("path")
      .attr("class", "line")
      .attr("d", function(d) { return line(d.values); })
      .style("stroke", function(d) { return color(d.name); });

 methods.append("text")
      .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
      .attr("transform", function(d) { return "translate(" + x(d.value.resolution) + "," + y(d.value.time) + ")"; })
      .attr("x", 3)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; });
});

</script>
    </body>
</html>
